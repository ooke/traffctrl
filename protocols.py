from marks import Mark
from datetime import datetime, timedelta
from typing import *

class Host(Protocol):
    def __init__(self, name: str, ips: Union[Tuple[str, ...], None] = None): ...
    @property
    def name(self) -> str: ...
    @property
    def ips(self) -> Tuple[str, ...]: ...
    @property
    def namelist(self) -> Tuple[str, ...]: ...
    
class Usage(NamedTuple):
    ref: Optional[str]
    inp: int = 0
    out: int = 0
    pkg: int = 0
    dat: int = 0

    def __add__(self, other: "Usage") -> "Usage": # type: ignore[override]
        return Usage(self.ref, self.inp + other.inp, self.out + other.out,
                     self.pkg + other.pkg, self.dat + other.dat)
    def __sub__(self, other: "Usage") -> "Usage":
        return Usage(self.ref, self.inp - other.inp, self.out - other.out,
                     self.pkg - other.pkg, self.dat - other.dat)
    
DataRow = Tuple[int, str, int, int, int, int, int, int, int, int, int, str]

class Entry(Protocol):
    def __init__(self) -> None: ...
    @property
    def row(self) -> DataRow: ...
    @row.setter
    def row(self, row: DataRow) -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def host(self) -> str: ...
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def dat_in(self) -> int: ...
    @property
    def dat_out(self) -> int: ...
    @property
    def dat_pkg(self) -> int: ...
    @property
    def dat(self) -> int: ...
    @property
    def router(self) -> str: ...
    @property
    def ts(self) -> datetime: ...
    
class Storage(Protocol):
    _conn: Any
    def __init__(self, accounts: Tuple["Account", ...], data_path: str) -> None: ...
    def load_data(self, start_ts: datetime, days: int) -> None: ...
    def apply_mask(self, start_ts: datetime, cb: Callable[[DataRow], Optional[bool]],
                   flt: Optional[str] = None, direction: str = 'future',
                   args: Tuple[Any, ...] = tuple()) -> None: ...
    def update_entries(self, column: str, changes: Iterable[Tuple[int, Union[str, int]]]) -> None: ...
    def sum(self, start_ts: datetime, end_ts: datetime,
            flt: Optional[str] = None,
            reference_column: str = 'host') -> Generator[Usage, None, None]: ...
    
class Limit(Protocol):
    def __init__(self, name: str, amount: int, period: int): ...
    @property
    def name(self) -> str: ...
    @property
    def period(self) -> timedelta: ...
    @property
    def amount(self) -> int: ...
    @property
    def amount_text(self) -> str: ...
    @property
    def amount_html(self) -> str: ...

class LimitSet(Protocol):
    def __init__(self, limit_names: Tuple[str, ...]) -> None: ...
    @property
    def limit_names(self) -> Tuple[str, ...]: ...
    def set(self, limit: str, amount: int) -> "LimitSet": ...
    def limit(self, limit: str) -> Limit: ...
    def __call__(self, limit: str) -> Limit: ...
    def period(self, limit: str) -> timedelta: ...

class Account(Protocol):
    def __init__(self, short: str, name: str, hosts: Tuple[Host, ...], limit: LimitSet, mark: Mark) -> None: ...
    def _set_storage(self, storage: Storage) -> None: ...
    @property
    def short(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def hosts(self) -> Tuple[Host, ...]: ...
    def host_by_name(self, host_name: str) -> Host: ...
    @property
    def limit(self) -> LimitSet: ...
    @property
    def mark(self) -> Mark: ...
    @property
    def color(self) -> str: ...
    @property
    def ignore(self) -> bool: ...
    @property
    def no_hardlimit(self) -> bool: ...
    def amount(self, limit_name: str) -> int: ...

#AddsEntry = Tuple[datetime, str, str, Optional[str], Union[timedelta, int]]
class AddsEntry(NamedTuple):
    date: datetime
    add_type: str
    router: str
    host: Optional[str]
    amount: Union[timedelta, int]

class Additionals(object):
    def __init__(self, adds_path: str) -> None: ...
    @property
    def routers(self) -> Tuple[str, ...]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, name: str) -> Generator[AddsEntry, None, None]: ...
    def apply_to_storage(self, store: Storage,
                         collect_rows: Optional[Dict[AddsEntry, List[DataRow]]] = None) -> Dict[str, int]: ...
    def _apply_boost_entries(self, row: DataRow, ets: datetime, entries: List[int],
                             collect_rows: Optional[List[DataRow]] = None) -> bool: ...
    def _apply_data_entries(self, row: DataRow, ts: datetime,
                            data: Dict[str, int],
                            entries: List[Tuple[int,int]],
                            collect_rows: Optional[List[DataRow]] = None) -> bool: ...

